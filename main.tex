\documentclass[a4paper]{article}

\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{listings}
\usepackage[colorinlistoftodos]{todonotes}

\usepackage{enumitem}
\usepackage{subfig}
\usepackage{multirow}

\newcommand{\COMMENT}[1]{}

\lstset{
	language=C,
    basicstyle=\small\ttfamily,
    breaklines=true
}

\newsavebox{\producerpushbox}
\newsavebox{\producertakebox}
\newsavebox{\consumerstealbox}

\title{Work Stealing Queue}

\begin{document}
\maketitle

\noindent 
\section{Algorithm Outline}
In this section, the algorithm of the work stealing queue (WSQ) is analyzed.
The analysis is first done assume sequentially consistent (SC) semantics.
The analysis for total-store ordering (TSO) semantics will be done once the SC analysis is complete.

The code of WSQ is given in Fig.~\ref{fig:WSQ}. 
The two procedures {\tt take} and {\tt push} are intended to be used by the owner of the task buffer, {\tt tasks}.
The former is the removal of a task from the buffer; the latter is the insertion of a new task into the buffer.
The remaining procedure {\tt steal} is to be used by threads that do not own the buffer.
Relative to a particular task buffer, we call the owner of the buffer {\em producer}. 
The threads that do not own the buffer are called {\em consumers}.
In what follows, we will pretend that there is a single task buffer, turning the problem into a standard single-producer, many-consumer protocol.

\begin{lrbox}{\producerpushbox}%
\begin{minipage}[t]{.45\linewidth}%
\vspace*{\fill}
\begin{lstlisting}
 push(task)
 {
  t := T;
  tasks[t] := task;
  T := t+1;
 }
\end{lstlisting}%
\end{minipage}%
\end{lrbox}

\begin{lrbox}{\producertakebox}%
\begin{minipage}[t]{.45\linewidth}%
\begin{lstlisting}
 take()
 {
  t := T-1;
  T := t;
  h := H;
  if(t<h) {
   T := h; 
   res := EMPTY; return;
  }
  task := tasks[t];
  if (t>h) {
   res := task; return;
  }
  succ := CAS(H,h,h+1);
  if (succ) {
   T := h+1;
   res := task; return;
  } else {
   res := EMPTY; return;
  }
 }
\end{lstlisting}%
\end{minipage}%
\end{lrbox}%

\begin{lrbox}{\consumerstealbox}
\begin{minipage}[t]{.45\linewidth}
\begin{lstlisting}
steal()
{
 h := H;
 t := T;
 if (h >= t) {
  res := EMPTY; return;
 }
 task := tasks[h];
 succ := CAS(H,h,h+1);
 if (succ) {
  res := task; return;
 } else {
  res := ABORT; return;
 }
}
\end{lstlisting}
\end{minipage}
\end{lrbox}



\begin{figure}[t]
\centering
\begin{tabular}{cc}
\multirow{2}{*}{\subfloat[Removing a task.]{\usebox{\producertakebox}}} 
&
%\multirow{1}{*}{\subfloat[Stealing a task.]{\usebox{\consumerstealbox}}}
\\
&
\subfloat[Stealing a task.]{\usebox{\consumerstealbox}}
%\multirow{-2}{*}{\subfloat[Stealing a task.]{\usebox{\consumerstealbox}}}
\\
& \subfloat[Inserting a task.]{\usebox{\producerpushbox}}\\
\end{tabular}
\\
\caption{The pseudo-code for the Work Stealing Queue (WSQ).}
\label{fig:WSQ}
\end{figure}

\COMMENT{
\begin{figure}
\begin{lstlisting}
\caption{The consumer side.}
\label{fig:consumer}
\end{figure}
}

\newcommand{\taketinit}{\ensuremath{T_{t,init}}}
\newcommand{\takehinit}{\ensuremath{H_{t,init}}}
\newcommand{\taketdecr}{\ensuremath{T_{t,decr}}}
\newcommand{\taketsucc}{\ensuremath{T_{t,succ}}}
\newcommand{\takehsucc}{\ensuremath{H_{t,succ}}}
\newcommand{\taketfail}{\ensuremath{T_{t,fail}}}
\newcommand{\taketexit}{\ensuremath{T_{t,exit}}}
\newcommand{\takehexit}{\ensuremath{H_{t,exit}}}

\paragraph{Remarks.}
We start by stating some obvious facts about the algorithm. 
The intention is to gather some knowledge base, going bottom up. 
As the facts become more and more intricate, the accompanying proofs will have to be included. 
Eventually, though, all {\em facts} must be supported by formal arguments.

We will use the following notation:
\begin{itemize}
\item $\taketinit$ denotes the value of {\tt T} as seen by the first read in {\tt take}.
\item $\takehinit$ denotes the value of {\tt H} as seen by the first read in {\tt take}.
\item $\taketdecr$ denotes the value of {\tt T} after the first decrement in {\tt take}.
\item $\taketsucc$ denotes the value assigned to {\tt T} after the successful {\tt CAS} in {\tt take}.
\item $\takehsucc$ denotes the value assigned to {\tt H} by the successful {\tt CAS} in {\tt take}.
\item $\taketfail$ denotes the value of {\tt T} following the failed {\tt CAS} in {\tt take}.
\item $\taketexit$ denotes the most recent value assigned to {\tt T} during the execution of {\tt take}.
\item $\takehexit$ denotes the most recent value assigned to {\tt H} during the execution of {\tt take}.
\end{itemize}
\begin{enumerate}[label=\bfseries Rem \arabic*:]
\item The global variable {\tt T} is modified only by the producer. 
The other global variable {\tt H} is modified by both the producer and the consumer.
\item The global variable {\tt H} is monotonically non-decreasing. 
In particular, any action either leaves {\tt H} unchanged or increments it by 1.
\item {\tt T} is incremented by 1 in {\tt push}.
\item {\tt T} is always decremented by 1 at the beginning of {\tt take}.
In other words, $\taketdecr=\taketinit-1$.
\item It is not true that {\tt T} is always greater than {\tt H}. 
\item If $\taketinit$ was greater than $\takehinit+1$, then no synchronization with consumers is performed.
There is no further modification of {\tt T} or {\tt H}.
That is, $\taketexit=\taketdecr=\taketinit-1$ and $\takehexit=\takehinit$.
\item If $\taketinit$ was less than or equal to $\takehinit$, then $t$ is strictly less than {\tt H}, which is not necessarily equal to $\takehinit$, which again means that there is no synchronization with consumers.
However, $\taketexit$ is set to point to $\takehinit$.
\item If $\taketinit$ was equal to $\takehinit+1$, then there is an attempt to synchronize with consumer threads.
If {\tt H} has not been updated by any other concurrent (consumer) thread, that is $\mathtt{H}\neq\takehinit$, then {\tt H} is incremented by 1.
This implies that {\tt H} assumes the value $\takehinit+1$.
This also implies that immediately after the increment, we have $\taketdecr=\mathtt{H}-1$. 
This justifies the remark above about the invariant $\mathtt{T}\geq \mathtt{H}$ not holding.
So the subsequent assignment to {\tt T} of $\mathtt{h}+1$ will set $\taketexit=\takehexit$. 
\item We conjecture that if $\takehexit\neq\takehinit$, which means that a successful {\tt CAS} had been performed by {\tt take}, $\takehexit$ is not modified by any consumer thread until {\tt take} terminates.
\end{enumerate}


\COMMENT{
\begin{tabular}{|p{3.6cm}|p{3.6cm}|p{3.6cm}|}
PUSH & TAKE & STEAL \\

\begin{lstlisting}
H: int, init 0
T: int, init 0
tasks: [W]

push(task)
{
 t := T;
 tasks[t mod W] := task;
 T := t+1;
}
\end{lstlisting} &

\begin{lstlisting}
take()
{
 t := T-1;
 T := t;
% 3. fence();
 h := H;
 if(t<h){
  T := h;
  res := EMPTY;
  return;
 }
 task := tasks[t mod W];
 if (t>h) {
  res := task;
  return;
 }
 succ := CAS(H,h,h+1);
 if (succ) {
  T := h+1;
  res := task;
  return;
 } else {
  res := EMPTY;
  return;
 }
}

 ------------------
 Synchronization 
 protocol        
 (worker inside) 
 ------------------
 


\end{lstlisting} &

\begin{lstlisting}
steal(){ 
 ------------------
 Synchronization 
 protocol        
 (thief inside)  
 ------------------
}

\end{lstlisting} 

\end{tabular}
}

%\newline

This is an example of work stealing algorithm. Basically, all work stealing queue algorithms strive to reduce overhead experienced by workers performing the computation, even at the cost of making steal operations more expensive.  As a result, these algorithms have converged on a similar design in which the worker uses a protocol based on the flag principle. If so, workers switches to a heavier synchronization protocol to decide whether the worker or thief gets the task.

The queue consistes of a cyclic array of W tasks with non-overlapping head and tail indices, an index with value i points to element i mod W of the tasks array. The head H, points to the oldest task in the queue. The tail, T , points to the first unused array element. if T==H the queue is empty. (Resizing isini simdilik salliyorum.)

A worker performs a put() by storing the task at the tail of the queue, and then incrementing T. \textit{Note: TSO model guarantees that the store of the task and subsequent store incrementing T are not reordered.}

To take() a task, the worker "raises its flag" by decrementing T from t+1 to t, thereby publishing its intent to take task t(the task pointed to by index t). It then reads the head index H after issuing a memory fence to ensure that reading H is not reordered before decrementing T.

If the worker observers that t>H, it can safely remove task t from the queue, as it has verified there can be no conflict for task t: when the tail update became globally visible, thieves have annouced intent to steal only tasks up to H<t, which means that a new steal operation will observe a queue that does not contain task t.

However if the worker observes that t<=H there may be a conflict with a thief. The algorithms differ in the synchronization protocol used to handle such a conflict.

\end{document}